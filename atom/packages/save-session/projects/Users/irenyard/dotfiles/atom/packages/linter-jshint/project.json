[{"diskText":"linterPath = atom.packages.getLoadedPackage(\"linter\").path\nLinter = require \"#{linterPath}/lib/linter\"\n{findFile, warn} = require \"#{linterPath}/lib/utils\"\n\nclass LinterJshint extends Linter\n  # The syntax that the linter handles. May be a string or\n  # list/tuple of strings. Names should be all lowercase.\n  @syntax: ['source.js', 'source.js.jquery', 'text.html.basic']\n\n  # A string, list, tuple or callable that returns a string, list or tuple,\n  # containing the command line (with arguments) used to lint.\n  cmd: ['jshint', '--verbose', '--extract=auto']\n\n  linterName: 'jshint'\n\n  # A regex pattern used to extract information from the executable's output.\n  regex:\n    '((?<fail>ERROR: .+)|' +\n    '.+?: line (?<line>[0-9]+), col (?<col>[0-9]+), ' +\n    '(?<message>.+) ' +\n    # capture error, warning and code\n    '\\\\(((?<error>E)|(?<warning>W))(?<code>[0-9]+)\\\\)'+\n    ')'\n\n  isNodeExecutable: yes\n\n  constructor: (editor) ->\n    super(editor)\n\n    config = findFile @cwd, ['.jshintrc']\n    if config\n      @cmd = @cmd.concat ['-c', config]\n\n    atom.config.observe 'linter-jshint.jshintExecutablePath', @formatShellCmd\n\n  formatShellCmd: =>\n    jshintExecutablePath = atom.config.get 'linter-jshint.jshintExecutablePath'\n    @executablePath = \"#{jshintExecutablePath}\"\n\n  formatMessage: (match) ->\n    type = if match.error\n      \"E\"\n    else if match.warning\n      \"W\"\n    else\n      warn \"Regex does not match lint output\", match\n      \"\"\n\n    \"#{match.message} (#{type}#{match.code})\"\n\n  destroy: ->\n    atom.config.unobserve 'linter-jshint.jshintExecutablePath'\n\nmodule.exports = LinterJshint\n","text":"linterPath = atom.packages.getLoadedPackage(\"linter\").path\nLinter = require \"#{linterPath}/lib/linter\"\n{findFile, warn} = require \"#{linterPath}/lib/utils\"\n\nclass LinterJshint extends Linter\n  # The syntax that the linter handles. May be a string or\n  # list/tuple of strings. Names should be all lowercase.\n  @syntax: ['source.js', 'source.js.jquery', 'text.html.basic']\n\n  # A string, list, tuple or callable that returns a string, list or tuple,\n  # containing the command line (with arguments) used to lint.\n  cmd: ['jshint', '--verbose', '--extract=auto']\n\n  linterName: 'jshint'\n\n  # A regex pattern used to extract information from the executable's output.\n  regex:\n    '((?<fail>ERROR: .+)|' +\n    '.+?: line (?<line>[0-9]+), col (?<col>[0-9]+), ' +\n    '(?<message>.+) ' +\n    # capture error, warning and code\n    '\\\\(((?<error>E)|(?<warning>W))(?<code>[0-9]+)\\\\)'+\n    ')'\n\n  isNodeExecutable: yes\n\n  constructor: (editor) ->\n    super(editor)\n\n    config = findFile @cwd, ['.jshintrc']\n    if config\n      @cmd = @cmd.concat ['-c', config]\n\n    atom.config.observe 'linter-jshint.jshintExecutablePath', @formatShellCmd\n\n  formatShellCmd: =>\n    jshintExecutablePath = atom.config.get 'linter-jshint.jshintExecutablePath'\n    @executablePath = \"#{jshintExecutablePath}\"\n\n  formatMessage: (match) ->\n    type = if match.error\n      \"E\"\n    else if match.warning\n      \"W\"\n    else\n      warn \"Regex does not match lint output\", match\n      \"\"\n\n    \"#{match.message} (#{type}#{match.code})\"\n\n  destroy: ->\n    atom.config.unobserve 'linter-jshint.jshintExecutablePath'\n\nmodule.exports = LinterJshint\n","active":false,"path":"/Users/irenyard/dotfiles/atom/packages/linter-jshint/lib/linter-jshint.coffee","scroll":2.0666666666666664,"cursor":{"row":0,"column":0}}]